# -*- coding: utf-8 -*-
"""caminho_minimo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18dxqN0PgHlOHHjNAdgSeOcuySU2eni7s
"""

#casas do grafo BFS caminho minimo entre regiões

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np

team_black = ["Casa Velaryon", "Casa Stark", "Casa Arryn", "Casa Greyjoy", "Casa Tully"]
team_green = ["Casa Baratheon", "Casa Hightower", "Casa Lannister", "Casa Strong"]

G = nx.Graph()

G.add_nodes_from(team_black + team_green)

edges = [
    ("Casa Velaryon", "Casa Stark"),
    ("Casa Stark", "Casa Arryn"),
    ("Casa Arryn", "Casa Greyjoy"),
    ("Casa Greyjoy", "Casa Tully"),
    ("Casa Tully", "Casa Velaryon"),
    ("Casa Baratheon", "Casa Hightower"),
    ("Casa Hightower", "Casa Lannister"),
    ("Casa Lannister", "Casa Strong"),
    ("Casa Strong", "Casa Baratheon"),
    ("Casa Velaryon", "Casa Baratheon"),
    ("Casa Stark", "Casa Hightower"),
    ("Casa Arryn", "Casa Lannister"),
    ("Casa Greyjoy", "Casa Strong"),
    ("Casa Tully", "Casa Baratheon")
]

G.add_edges_from(edges)


def bfs_shortest_path(graph, start, goal):
    explored = []
    queue = [[start]]

    if start == goal:
        return [start]

    while queue:
        path = queue.pop(0)
        node = path[-1]

        if node not in explored:
            neighbours = graph[node]

            for neighbour in neighbours:
                new_path = list(path)
                new_path.append(neighbour)
                queue.append(new_path)

                if neighbour == goal:
                    return new_path

            explored.append(node)

    return None

min_paths = []
for black_house in team_black:
    for green_house in team_green:
        path = bfs_shortest_path(G, black_house, green_house)
        min_paths.append((black_house, green_house, path))
        print(f"Caminho mínimo de {black_house} para {green_house}: {path}")


pos = nx.spring_layout(G)
plt.figure(figsize=(12, 8))

nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=2000, font_size=10, font_weight='bold')

#cores agora são baseadas não em relações entre nós, e sim em qual time as familias pertencem
nx.draw_networkx_nodes(G, pos, nodelist=team_black, node_color='red', node_size=2000, alpha=0.6)
nx.draw_networkx_nodes(G, pos, nodelist=team_green, node_color='green', node_size=2000, alpha=0.6)

for path in min_paths:
    if path[2]:
        edges_in_path = [(path[2][i], path[2][i+1]) for i in range(len(path[2])-1)]
        nx.draw_networkx_edges(G, pos, edgelist=edges_in_path, edge_color='r', width=2)

plt.title("Grafo das Casas e Caminhos Mínimos entre Team Black e Team Green")
plt.show()